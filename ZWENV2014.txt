BOOST=		C:\zwLibs\boostMini725
CRYPTOPP=	C:\zwLibs\Cryptopp562VC10Lite
GTEST		C:\zwLibs\gtest-1.7.0VC10Bin
JCLOCKIP	localhost
MIRACL		C:\zwLibs\zwMiracl2014.hg\MIRACL2014\miraclSrc\include
POCO		C:\zwLibs\poco-1.4.6p4
SWIG_LIB	C:\zwLibs\swigwin-3.0.2\Lib
ZWBINJCLOCK	C:\zwLibs\exe

11:04 2014/8/12 ATMC安装VC2010 REDIST之后系统异常，需要编译一个纯静态版本，没有任何VCREDIST的安装包；
11:10 2014/8/12 回去做一个开发用VHD文件，可以方便的放到其他机器上；
11:12 2014/8/12 ATMC平台是紫金技术的。他们用VC6写的平台；按照我之前测试过的，编译为静态的，就没问题了；
11:23 2014/8/12 还需要一个3G/4G无线网卡；BOOST/POCO等所有依赖库的源代码都应该准备好；张靖钰的QQ号码；
11:32 2014/8/12 b2 --toolset=msvc-10.0 --build-type=complete --with-thread --with-chrono --with-date_time --with-random --with-system
Properties:
  toolset=toolset         Indicate the toolset to build with.
  variant=debug|release   Select the build variant
  link=static|shared      Whether to build static or shared libraries
  threading=single|multi  Whether to build single or multithreaded binaries
  runtime-link=static|shared
                          Whether to link to static or shared C and C++
                          runtime.
13:05 2014/8/12	LIBCMT.LIB;LIBCPMT.LIB;MSVCRT.LIB;MSVCPRT.LIB
13:50 2014/8/12	http://cznic.dl.sourceforge.net/project/boost/boost/1.55.0/boost_1_55_0.7z
13:50 2014/8/12 我的DLL切换到BOOST 1.55以外的其他版本编译之后，测试就跑不过去。暂时没空找原因。起因是需要改为静态链接，我手头暂时没有1.55的源代码，出发前太仓促没有准备周全。我当时在建行的机房，就直接用一个1.54beta试了试，不行。后来回到酒店，上网下了1.56，好像也有问题，这个事情回北京再研究。
但是我后来发现，其实就是DLL切换为静态编译造成的，和boost版本没什么直接关系；
另外听说紫金的系统是VS2003编译的，我用那个版本应该没什么问题；或者要么用MingW编译，CMake；
2014/8/12 14:49:28 果然，换用BOOST 1.56以后，没什么问题。问题就是由DLL的静态编译造成的；
2014/8/12 15:03:05我发现DEBUG模式下，多线程调试DLL，预处理器去掉_USR_DLL,添加POCO_STATIC，这样编译出来的，不依赖于POCO了，暂时还依赖于VCREDIST，测试可以通过；
2014/8/12 15:29:19 我发现在完全静态编译的情况下，只有0000报文的测试会导致一个堆栈损坏，关掉该测试，其余4个测试都可以跑过去。
2014/8/12 15:32:53 紫金的人装了一个VS2010运行环境，我的gtest在ATMC上连接锁具跑0000和0001报文测试通过了；现在可以测试了；不过我还是要继续检查0000报文处理在静态编译下的问题所在，总是一个隐患；
 RtlValidateHeap( 007F0000, 0080B688 )
 RtlValidateHeap( 013E0000, 015FB688 )
 RtlValidateHeap( 015C0000, 014BB688 )
 总结，总是在最后16bit的地方偏移为B688的地方出问题；
2014/8/12 15:55:01 初步判断，我发现是0000报文里面zwRecvLockData函数的调用造成了堆栈损坏；
2014/8/12 15:55:57 刚才听人说，一台银行设备，内部异常，原因是杀毒软件把IE杀掉了。。(接着听说：一般情况下多半是杀毒软件把IE杀掉了，看来IE经常被杀毒软件杀掉
2014/8/12 16:12:22 我刚才添加了版本信息到DLL里面，两位基本就是1,1了，代表1.1版本，后面两位，产品信息是2014,8，代表2014年8月，文件信息是8,12，代表8月12日；这样容易人工识别；
2014/8/12 16:27:03初步看了看，只有gtest的测试程序估计是涉及的东西比较多，一时半会难以弄成完全静态的；其他的模拟锁具，以及DLL本身，都做成静态的了，运行gtest没问题；


2014/8/12 16:50:58 bcp裁剪了1.56的两个库,thread和property_tree，可以编译过去；
bcp property_tree C:\zwLibs\boost156Mini812

2014/8/12 18:37:08 今天紫金的刘工给力我们上次已经拿到过的那个OCX测试工具，开始的时候怎么都不被调用，没有反应，后来regsvr32注册了该OCX之后才被调用，但是一LOAD我们的DLL，IE9就会停止工作，还需要调试；
2014/8/12 20:00:24 我把我的DLL回滚到版本2，也就是没有任何功能的空壳，试验了一下，是可以成功的被紫金技术的OCX通过IE调用不会导致IE停止工作的；
HidProtocol
[ThirdParty]
Dll=D:\ccbwk08\EXE\BIN\HidProtocol.dll
版本94，没有细看，至少IE没有停止工作，但是Open返回-1.
MessageBoxA(NULL,"20140812.2013","JinChu",MB_OK);
return 2103;
2014/8/12 20:40:47 紫金的OCX的配置文件里面指定的DLL名字必须是全路径名，否则无法LOAD；可以通过procMon来监测IE的LoadImage看看我的DLL到底被调用了没有；
版本100，能Load但是Open失败；
版本10，能Load，Open成功；
版本17，能Load，Open成功；
版本19，能Load，Open成功；
版本20，能Load，Open成功；
版本21，能Load,Open失败；
版本22，能Load,Open失败；
版本30，能Load,Open失败；
2135.经过反复试验，诡异的事情，版本20到21之间，由于.def增加了一个导出函数zwTestWebSocket，就会导致Open无法被上层OCX成功调用；
2142.把.DEF内部改为
Open @ 1
Close @ 2
Notify @ 3
SetRecvMsgRotine @ 4
之后，版本22好了；26和27之间又出问题了，又是无法成功调用Open;
2151.26和27之间，主要是添加了一个zwWebSocket类型的全局静态对象，以及一个使用该对象的测试函数zwTestWebSocket，还将该函数导出了。去掉以后，还把DEF文件编号固定函数序号以后就好了；28，29这么修改也还有效；但是之前我看到30这么修改无效；30好像是因为另一个地方的全局静态对象启动了网络连接，所以失败的；我试试看140版本，不自动启动通信线程看看能否成功调用Open
版本60：单独删除内部自动网络连接，无效；加上更改DEF，好了，可以成功调用Open;
版本90，同上2项，通过；
版本95，添加了通信线程，尚未有实质性功能，以上2项修改后可以通过；
版本108，同上2项，开始导致IE挂掉；
版本120，同上2项，开始导致IE挂掉；禁止通信线程自动启动，以及内部使用的网络连接对象以后，测试通过；也就是说：DEF文件，网络连接对象，通信线程三者修改或者禁用；
138，DEF,通信线程；不会挂；
144，DEF,通信线程；不会挂；
150，DEF,通信线程；不会挂；
160，DEF,通信线程；不会挂；
168，DEF,通信线程；不会挂；转换为静态编译版本之前；170，IE挂了；169，挂了，相对没挂的168而言，只是改了一些项目设置；169把静态链接改为DLL之后就不会导致IE挂了；据我观察，是设置完毕回调函数以后，IE就挂掉了；但是动态编译虽然没有挂掉，但是也根本没有被调用；
		OutputDebugStringA("2323");
		break;
2014/8/13 9:13:27 广开中心，周二情况汇报
周二早上，我和张靖钰去了建行广开中心，韦彪茂因为运动受伤不在，他的同事接待我们的，把我们领到旁边一个楼里面的ATM设备测试机房，里面有很多ATM厂家的设备和人员，把其中一家，紫金技术的工程师，姓刘，介绍给我们后建行的人就走了；然后我们开始测试；
首先第一件事，当前我们的DLL以及用到的一些支持库，都需要一个vc2010运行库的支持，大约4M大小的一个exe，安装一下就行了，这是微软提供的标准组件；但是紫金的ATMC系统，本身是使用VC2003和VC6混合开发的，装了2010的这个运行库之后就莫名其妙的在重启时发生异常无法启动；他们的系统是XP；
后来他们经过重装之后能运行我们的DLL以及测试程序了，我们的DLL和测试程序，以及锁具，连在真实的ATMC上，跑通了我们自己的测试程序(此时DLL使用的动态链接，安装VC2010支持库的方式)；
但是接下来又发生ATMC重启之后无法成功启动，经过紫金的人检测，大体上可能与我们的锁具模拟网卡的方式有关；具体如何处理，当时我在现场改程序，没在ATMC那里看着，详情请问张靖钰；
后来我在现场把DLL改为静态编译的了，不必安装那个VC2010支持库了，但是到了他们的下班时间，他们就先给我们一个单机测试工具试试看；我发现和我们在出发前两天才拿到的那个“单体测试工具”是一样的，我这次又发现，我们的DLL还是根本不会被调用；
我们的DLL被调用的具体的方式是这样的：IE打开一个他们提供的网页文件，网页在底层调用他们的一个OCX，OCX在底层调用我们的这个按照他们的接口标准写好的DLL；等于是网页-OCX-我们的DLL这样一层层调用下来；
后来我找到原因，要手工注册他们的OCX之后，我们的DLL才会被调用；但是这样做了之后，我发现我们的DLL导致IE挂掉，也就是测试失败；
我又从版本控制系统里面翻出来7月25日开始开发时的空壳版本，发现可以被紫金的OCX成功调用，正确的返回一个例子返回值，并且不会导致IE挂掉；
现在我就在逐步查找我们的DLL和紫金的OCX不匹配的原因中；昨晚尝试了很多次，大致原因已经有了，和为了实现异步回调函数做的多线程，以及网络通信有关，今天继续找原因；

我现在在酒店房间写程序；建行机房有网络但是不给我们使用；没有网络的话，简单修改一下还行，像现在这样大动程序，没有网络查资料不行；
我的总结：
	我们得知ATMC具体系统使用VS2003/VC6开发的太晚了，到了现场才知道；我用VC2010开发是因为XML，JSON，WEBSOCKET等第三方支持库对于较高版本VC支持比较好，这样可以集中精力解决业务问题而不是耗费精力在这些基础支持库上；用VC6的话虽然出来的结果兼容性比较好，但是就得花费大量精力解决基础支持库的问题有时候还得自己写，不适合我们现在时间很紧的情况；
	我们知道那个“单体测试工具”的存在，以及拿到该工具太晚了，7月底我开始开发这个DLL的时候就拿到的话，会导致配合紫金的OCX出问题的情况当时就可以查出来，当时就改正，不用现在在广州大动程序；
	ATMC的USB接口还是很紧张的，我们的锁具占用了最后一个可用USB接口，共有十多个；
	

2014/8/13 9:29:08
b2 --toolset=msvc-7.1 --build-type=complete --with-thread --with-chrono --with-date_time --with-random --with-system

2014/8/13 11:06:51
解决不安装VC运行库（VC2005，VC2008），程序运行出错的方法。
分类： C++ 2012-06-22 16:01 724人阅读 评论(0) 收藏 举报
microsoft工具c
因为VS2005以后程序采用了manifest的生成方式，所以发布的时候要和运行库一起发布。但是我们平时开发和发布的时候如果都要客户安装运行库，那就不太方便了。你可以Microsoft下载：http://www.microsoft.com/zh-cn/download/details.aspx?id=2092
我说说不用安装VC2008运行库的方法：
一、先要在编译程序的时候，把程序的manifest生成方式修改下，清单工具->嵌入清单（否），重新生成。
二、将主程序和生成的xxx.exe.manifest复制在同一文件夹，然后将C:\Program Files\Microsoft Visual Studio 9.0\VC\redist\下的相应运行库文件夹也复制到同一目录下（不是所有都要复制的，看你的程序用到了哪些库），我的只用到了CRT。
三、打开xxx.exe.manfitest文件，查看版本（version="9.0.21022.8"），然后装目录下运行库里所有的xxx.maniftest中的版本修改成xxx.exe.manfitest中的版本一样。
现在打开程序看看，是不是已经可以打开了，哈哈。
注意：如果你的程序全采用的是MT且静态链接的形式，那就不用运行库的了。
